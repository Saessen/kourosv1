lien trello 
https://trello.com/invite/b/Xn891lMB/ca693a709c5cbf7f27d434de8a67b43f/kouros

ANCHOR Authentification oAuth

Sur ce projet nous avons mis en place un syst√®me d'authenfication via google avec le bundle knpuniversity/oauth2-client-bundle
doc: https://github.com/knpuniversity/oauth2-client-bundle
oauth2 permet de se connecter via les r√©seaux (linkedin, facebook, google etc)
L'objectif sur Kouros √©tait de faire une identification via google dans le but final est la r√©cup√©ration et la transmission du planning.
Celle ci est possible en passant diff√©rent scopes en param√®tre.
Pour d√©marrer il faut cr√©er une api sur google. Les codes (clientId et clientSecret) .


1 (d√©ja fait ) installation du bundle composer require knpuniversity/oauth2-client-bundle

2 (d√©ja fait) installation librairie du client oauth, ici google (dans doc voir configuration du client) 
    composer require league/oauth2-google

3 (d√©ja fait)php bin/console make:user + make:entity User pour ajouter image et fullname

4 (d√©ja fait) cr√©er un controller homepage qui permettra d'avoir un lien de connexion

5(d√©ja fait) cr√©ation de l'application google, permettra d'avoir des identifiants dont google a besoin pour identifier notre application
Dans la console google devlopers:(utilisation de l'adresse mail : devkouros@gmail.com password: @devKouros2021)
 Sur: https://console.cloud.google.com/home/
 Dans API et services -> identifiants -> cr√©er des identifiants ->ID client Oauth
 type d'application = appli web
 nom = ecrire le nom du projet (le nom en lui m√™me n'a pas d'importance c'est surtout pour l'identifier rapidement sur le tableau de bord de la console google)
 uri = http://127.0.0.1:8001 (servira de point d'entr√©e pour l'authentification)
 uri redirection = http://127.0.0.1:8001/connect/google/check (route post authentification)
 ->cr√©er<-
 La console google a cr√©e notre client et affiche les identifiants a conserver et a renseigner dans le .env id client et code secret 

 id: 113392687962-5jtcjp75mtl0lkhb3etudduqi300tatf.apps.googleusercontent.com
 secret: ScFWXGkDjVgymM07hAyWJ5F5

 Une fois les Id clients enregistr√©s dans le .env nous pouvons les utiliser sur tout le projet

 6 (d√©ja fait √† d√©commenter )Dans  config-> package -> knpu_oauth2_client.yaml 
 Faire la config: entrer le client , r√©cup√©ration des id du .env et la route de redirection.
 Ici il est possible d'ajouter plusieurs clients (par exemple linkedin etc) en suivant toujours le m√™me fonctionnement 

 7(deja fait )Cr√©ation du controller = GoogleController.php  qui va g√©rer les deux routes de connexion:
 celle ou on envoi la personne se connecter a google et celle ou google nous renvoi les infos 
 
 Si mise en place de plusieurs authentification, cr√©er un controller par client
 Le code √©crit dans le controller est dispo sur la doc github.
 La route connectAction est celle utilis√©e par le bundle, 
 Ensuite connect/ckeck = quand google nous renvoie les infos on regarde si le user est d√©j√† connect√©, si c'est le cas on le renvoi sur le dashboard

8(deja fait)Dans src -> new folder: Security->new file: googleAuthenticator.php
Si plusieurs clients oauth il faut cr√©er un fichier par client
Dans ce fichier il y a un construct: clientRegistry c'est le client de oauth, em pour notre base de donn√©es et router pour rediriger le user.
Fonctions impl√©ment√©es: 
    -support= pour v√©rifier si on est sur la bonne route
    -get credential = r√©cup√©ration du token google
    -get user = dans le token google on r√©cup√®re des infos du googleUser, on v√©rifie si le user existe, si pas le cas on le cr√©√©, sinon on le retourne directement
    -start = si le user n'est pas connect√© on redirige sur le login
    -failure= possibilit√© d'ajouter un message en cas d'echec de la connexion (non fait)
    -succes = possibilit√© d'ajouter un message pour signifier la connexion (non fait)

 9 (deja fait a d√©commenter) cr√©er le guard dans config->package-> security.yaml
 on dit au firewalls lorsque quelqu'un essaie de se connecter sur le projet on d√©clenche la classe s√©curity\googleauthenticator
Si plusieurs clients oauth2 il faut ajouter tous les authenticator et cr√©er un entry point exemple:
         main:
            lazy: true
            provider: app_user_provider
            entry_point: App\Security\GoogleAuthenticator
            guard:
                authenticators:
                    - App\Security\GoogleAuthenticator
                    - App\Security\LinkedinAuthenticator
(c'est ce qu'il faudra faire lorsque le make:auth sera r√©alis√©, c'est le App\Security\AppAuthenticator qui devra √™tre utilis√© comme entry_point)

10 (deja fait) Dans template Homepage ajouter le lien vers la connection google: {{ path('connect_google_start')}}

11 dans base.html.twig (d√©ja fait a d√©commenter): 
ajouter l'image de profil <img src="{{ app.user.image}}" class="photo" alt="Photo de {{ app.user.fullname}}" width="30" height="30" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Photo de {{app.user.email}}"> (ligne 26 √† d√©commenter)
ajouter route logout: {{ path('logout')}} (d√©ja fait √† d√©commenter ligne 27)
dans le dashboard (d√©ja fait): ajouter fullname du user : <p>Bonjour {{app.user.fullname|upper}}!</p> (ligne 13 a d√©commenter)

12 cr√©ation d'un template base_non_connect√© (d√©ja fait): sur le template de la home page extends cette base la. La base.html.twig sera utilis√©e si l'utilisateur est connect√©

13 A FAIRE il faudra aujouter un make auth, pour ne pas √™tre bloqu√© par un seul syst√®me d'authentification (si l'utilisateur n'a pas de compte google)
POSSIBILITE: il est possible de r√©cup√®re plus d'informations sur le googleUser en utilisant diff√©rents scopes. Doc: https://developers.google.com/identity/protocols/oauth2/scopes
C'est a partir de ces parma√®tres qu'il sera possible de r√©cup√©rer les agendas (qui seront utiliser pour les disponibilit√©s des formateurs)






Graphique: 
            Utilisation ChartJs lien doc: https://www.chartjs.org/docs/latest/charts/bubble.html
            (POC sur trello)
            R√©cup√©ration des donn√©es du devis 
            
PDF:
        Utilisation TCPDF lien doc: https://tcpdf.org/

Calendrier: 
        Utilisation Fullcalendar lien doc: https://fullcalendar.io/docs

Search: 
            Cr√©ation d'un formulaire pour la recherche + cr√©ation de la fonction dans le repository et appel de celle-ci dans le controleur 

Ckeditor:
            https://github.com/FriendsOfSymfony/FOSCKEditorBundle


‚ö† Fonctionnalit√©s r√©alis√©es avec symfony 4.7 et PHP 7.3 / 8.3 

ANCHOR - I - CREATION D'UN PDF AVEC TCPF 

        A - Installation et pr√©paration 

                1. Importer le bundle TCPF de jonasart avec la commande : composer require jonasarts/tcpdf-bundle

                2. Importer le bundle Ckeditor de friendsofsymfony avec la commande : composer require friendsofsymfony/ckeditor-bundle &&         L'installer avec la commande : php bin/console ckeditor:install &&
                L'installer dans le directory avec : php bin/console assets:install
                Dans config > packages > fos_ck_editor.yaml pr√©ciser si la toolbar doit √™tre basic, standard ou full.
                       üòé Pour une toolbar personnalis√©e : https://ckeditor.com/latest/samples/toolbarconfigurator/index.html#basic
                       ‚ö† En cas de projet partag√©, chaque participant devra faire l'installation de ckeditor et des assets apr√®s avoir fait un 
                       composer update pour r√©cup√©rer le dossier "vendor".

                3. Cr√©er une entit√© Template, son controller et son form (php bin/console make:crud). L'entit√© doit contenir un champs texte, des tags (str), le nom du fichier (str) // et √™tre reli√© √† l'entit√© Formations en ManyToMany (plusieurs templates pour plusieurs formations).
                        ‚ö† Le mieux est d'avoir d√©j√† cr√©√© les entit√©s Formations, Devis, Facture, Conventions etc.. ainsi que leurs forms car on va faire appel aux donn√©es de ces entit√©s pour g√©n√©rer un pdf.

                4. Cr√©er un dossier "templates" √† la racine du dossier "public". 
                        ‚ö† Pour pouvoir acc√©der √† des fichiers et les modifier depuis l'interface utilisateur on ne peut pas les laisser dans le dossier "templates" d√©j√† existant √† la racine du projet. C'est pourquoi on doit les mettre dans le dossier "public", comme le fichier index.php et les assets.

                5. Importer le composant filesystem de symfony avec la commande : composer require symfony/filesystem
                        Filesystem contient des m√©thodes qui nous servirons √† enregistrer nos templates dans des fichiers que nous pourrons appeler en fonction de leur r√¥le (devis, facture, etc...).

        B - Cr√©er un template 

                1. Dans TemplateController.php on injecte la classe Filesystem √† la fonction new (ne pas oublier de l'importer dans les use).

                2. On r√©cup√®re le nom du fichier entr√© dans le formulaire dans la variable $filename avec ->getFilename(). 

                3. Apr√®s avoir flusher les donn√©es du formulaire, on enregistre le fichier $filename que l'on concat√®ne avec une extension ".html.twig" dans public > templates gr√¢ce √† la m√©thode dumpFile(path_du_fichier/nom_du_fichier, contenu_du_fichier).

                4. Il faut modifier le path naturellement emprunt√© par Symfony pour aller chercher les fichiers non plus dans "templates" mais dans public > templates. Dans config > packages > twig.yaml on ajoute en dessous du 
                        default_path : '%kernel.project_dir%/templates'
                un nouveau path qui pr√©cise que l'on rentre dans le dossier public et auquel on donne un nom ('templates')
                            paths : 
                                '%kernel.project_dir%/public/templates' : 'templates'
                
                5. On doit donc obtenir ce genre de r√©sultat : 
                        $filesystem->dumpFile('templates/' . $filename . '.html.twig', $template->getTexte());
                

                6. Dans TemplateType, ins√©rer CKEditorType dans le champs ->add("texte") du formulaire. 
                        ‚ö† V√©rifier qu'il apparait bien dans les use. 
                
                7. Tester le formulaire et v√©rifier qu'un nouveau fichier au format ".html.twig" apparait bien dans public > templates. 

        C. G√©n√©rer un PDF (enfin!)

                1. On veut cr√©er un pdf √† partir des informations d'un des objets d'une entit√© (devis, facture, ...). Dans le controller de cette entit√© on va donc cr√©er une nouvelle route qu'on appellera d'un nom exquis tel "devis_pdf" et qui permettra d'ouvrir le pdf dans une nouvelle fen√™tre pour le t√©l√©charger. Cette route doit r√©cup√©rer avec GET l'id du devis que l'on souhaite transformer.

                2. Cr√©er une fonction makePdf() o√π le bundle de jonasart sera inject√©. La fonction fera √©galement appel √† l'entit√© Devis et √† son repository.
                        ‚ö† Le service TCPDF est appel√© de cette mani√®re :  \jonasarts\Bundle\TCPDFBundle\TCPDF\TCPDF $pdf 
                        V√©rifier que le use est correctement orthographi√©.

                3. On cherche le devis qu'on veut transformer par son id dans le repository gr√¢ce √† la m√©thode findBy($id)

                4. On instancie la classe TCPDF avec tous les param√®tres n√©cessaires. 
                        Pour personnaliser la mise en page des templates, on peut cr√©er une entit√© MYPDF qui extends la classe TCPDF √† la racine de "src" et y modifier la valeur de chaque param√®tre (m'voyez?). Il est aussi possible de modifier le style directement dans le twig avec du css. Attention cependant, le bundle ne permet pas d'utiliser des frameworks (pas de Bootstrap... pas de Bootstrap) ou du css trop √©labor√©.
                        ‚ö† Les diff√©rentes possibilit√©s de personnalisation sont sur le site que l'on a r√©f√©renc√© en haut de page. Pass√© le premier choc du template n¬∞6, vous aurez acc√®s √† toute l'√©tendue (hum) de vos possibilit√©s artistiques.
                
                5. On cr√©e la page avec la m√©thode addPage() de TCPDF.

                6. Ici, √ßa devient tricky. On veut faire appel √† un certain template pour une certaine entit√©. Nous avons d√©j√† cr√©√© le raccourci pour que Symfony retrouve nos vues dans le dossier public (mais si rappelez-vous, on l'a appel√© "templates" avec beaucoup d'originalit√©). 
                Si l'on veut g√©n√©rer un pdf pour le devis de l'entreprise X, on va isoler ce devis par son id et r√©cup√©rer ses informations pour les faire appara√Ætre dans le devis. Mais comment, P√®re Castor? 
                On va cr√©er une variable ($html) d'o√π l'on va appeler notre vue avec la m√©thode renderView() et o√π on va passer un array qui servira √† peupler la variable $devis. $devis servira √† faire passer les informations pertinentes attenantes √† un objet isol√© par son id. 
                        $html = $this->renderView('@templates/nom-du-template.html.twig', ['titre' => $devis->getFormations()->getTitre()]);

                        ü§ì Am√©lioration possible: On choisit un template et si besoin, on le modifie. Mais si on veut faire plusieurs templates pour eviter de modifier les donn√©es d√©j√† rentr√©es, il faut pouvoir choisir quel templates on souhaite utiliser. Pour l'instant ce n'est pas possible mais il faudrait que les utilisateurs puisse le faire cot√© front.
                
                7. On demandera toujours les m√™mes informations au client, celles qui sont stockables en bdd. Donc on peut pr√©voir quelles informations seront appel√©es et utilis√©es dans le template. L'array du renderView() doit √™tre aussi complet que possible. 
                Il n'y aura plus qu'√† appeler les informations dans le twig avec {{titre}}, {{prenom}}, {{prix_ttc}}, etc. 

                8. On "√©crit" la page du pdf avec le contenu de la variable $html gr√¢ce √† la m√©thode writeHtml(), puis on pr√©cise qu'il n'y a pas d'autre page √† cr√©er avec lastPage().

                9. On ferme et on exporte le document avec la m√©thode Output() qui n√©cessite deux param√®tres. Le premier est le nom sous lequel on va exporter le document et qui doit avoir une extension '.pdf'. Le second est une lettre qui va pr√©ciser la destination du fichier. 
                        'I' pour envoyer le pdf sur le navigateur (Il est enregistrable par la suite). C'est celui-ci qu'on utilise.
                        'F' pour l'enregistrer en tant que fichier directement. 
                        'D' pour l'envoyer sur le navigateur et forcer l'enregistrement du fichier.
                        'E' pour minifier le fichier en base64 et l'envoyer par mail. Le code devra √™tre compl√©t√© pour cela.
                
                10. Ins√©rer le lien pour g√©n√©rer un pdf sur la page voulue (ex: la page d'index des devis). Le path de la fonction et l'id du document doivent y figurer. 
                        <a class="btn btn-outline-light" href="{{ path('devis_pdf', {'id': devi.id}) }}">G√©n√©rer pdf</a> 

                11. Et voil√†, vous avez un pdf (√ßa fait plaisir). Pas un beau pdf car il reste encore toute la partie esth√©tique √† prendre en main (√ßa fait pas plaisir), mais un pdf que vous pouvez t√©l√©charger et garder en souvenir de ces joyeux moments pass√©s √† vous arracher les cheveux, le front en sueur et la bave aux... bref, joyeux. Merci qui? ü§ó


ANCHOR - II - CREATION D'UN CALENDRIER AVEC FULLCALENDAR.JS

                                        üöë Difficult√©: it's over 9000!! (sans la doc)

        A - Installation et pr√©paration

                1. Il existe des bundles √† importer dans Symfony pour les calendriers, le plus simple reste d'importer un lien cdn sur base.html.twig depuis le site de fullcalendar.js r√©f√©renc√© plus haut. Pour ceux qui ne trouvent pas:
                        <script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.8.0/main.min.js" integrity="sha256-AOrsg7pOO9zNtKymdz4LsI+KyLEHhTccJrZVU4UFwIU=" crossorigin="anonymous"></script>
                Il faut l'int√©grer entre la fin du {% bloc body %} et le d√©but du {% bloc javascripts %} sur base.html.twig 
        
                2. Vous avez le lien, maintenant il faut l'entit√© (ou les entit√©s). Cette entit√© va contenir toutes les propri√©t√©s qui permettront la cr√©ation d'un √©v√®nement. On peut nommer cette entit√© Calendrier, Event, etc mais dans le cadre de ce CRM, on va l'appeler Session, car les events qui seront pris en compte dans cette fonctionnalit√© sont les sessions (ta-da). On regarde bien la documentation pour voir quels param√®tres sont demand√©s en JS pour les passer √† notre Session. Comme nous sommes tr√®s raisonnables, nous nous sommes content√©es des 2/3 de la liste. 
                        ‚ö† Notez bien que les noms des param√®tres/propri√©t√©s ne doivent pas √™tre traduits ou modifi√©s, fullcalendar ne les reconnaitrait pas.
                Voici une liste (non-exhaustive) de param√®tres que vous pouvez entrer pour l'affichage des events sur le calendrier:
                        - title (parle de lui-m√™me, string 255 not null)
                        - start ( la date et l'heure du debut, c'est un datetime nullable, fonctionne uniquement avec end)
                        - end (la date et l'heure de fin, datetime nullable, exclusif √† start)
                                -> start et end sont exclusifs et utilis√©s pour des events continus et non-r√©p√©titifs. Si un event est r√©current, on va pr√©f√©rer utiliser les param√®tres suivants. 
                        - startTime (l'heure de d√©but, c'est un time nullable qui fonctionne avec endTime, startRecur, endRecur et daysOfWeek)
                        - endTime (l'heure de fin, time nullable)
                        - startRecur (la date de d√©but de l'occurence, date nullable)
                        - endRecur (la date de fin de l'occurence, date nullable)
                        - daysOfWeek (les jours de la semaine o√π l'occurence √† lieu, array d'integers) 
                                -> c'est l√† que √ßa se corse. Il doit apparaitre dans l'affichage en tant que param√®tre de l'event mais comme c'est un tableau, on va devoir cr√©er une entit√© DaysOfWeek en relation ManyToMany avec Session pour appeler des jours pass√©s en valeurs de DaysOfWeek.
                        - allDay (l'event dure toute la journ√©e ou pas, boolean)
                        - groupId (comme son nom ne l'indique pas c'est un nom que l'on va donner √† une session ou un ensemble de session pour pouvoir les modifier ensemble et pas une par une, string 255 nullable, je n'ai pas essayer de l'utiliser en dehors d'un event r√©current donc √† voir s'il fonctionne avec start et end)

                        - borderColor (couleur de la bordure de l'event sur l'affichage du calendrier, string 255 nullable)
                        - backgroundColor (couleur de fond de l'event sur l'affichage du calendrier, string 255 nullable)
                        - textColor (couleur du texte de l'event sur l'affichage du calendrier, string 255 nullable)
                                -> A faire pour plus tard: essayez de 'ramdomiser' le processus de choix des couleurs parce que rentrer √ßa √† chaque cr√©ation de Session.... urg.

                        - nbrDays (√ßa n'est pas un param√®tre pr√©d√©fini par fullcalendar, mais √ßa peut √™tre utile pour conna√Ætre le nombre de jours que va dur√©e la session et donc calculer son co√ªt, float nullable)
                        - nbrHours (m√™me principe que nbrDays mais pour les heures, float nullable)

                        - Tous les autres param√®tres li√©s √† la session comme formation ou prospect (on r√©cup√®re les donn√©es gr√¢ce aux relations) 
                
                3. Cr√©er une entit√© DaysOfWeek avec pour param√®tres:
                        - sessions (relation ManyToMany avec entit√© Session) 
                                -> cela doit cr√©er une table relationnelle dans votre bdd.
                        - name (nom des jours de la semaine, string 255 not null)
                        - number (chiffre correspondant √† un jour, int not null)
                        Le param√®tre daysOfWeek de fullcalendar est un tableau de nombres entiers.
                        
                        <script>
                           (...)
                                events: [
                                        daysOfWeek: ['0', '3', '4'],
                                        startTime: '09:00:00', 
                                        endTime: '10:00:00',
                                        startRecur: '2021-07-09',
                                        endRecur: '2021-09-01',
                                ]
                           (...)
                        </script>

                        Chaque jour de la semaine correspond √† un chiffre pr√©d√©fini (0 = dimanche, 1 = lundi, etc). Il est indispensable de faire correspondre ces chiffres avec les valeurs entr√©es en bdd. L'id ne doit pas √™tre utilis√© car il commencera √† 1 hors la valeur num√©rique de dimanche est 0 dans fullcalendar.
                
                4. Faire les CRUDs. Il en faut m√™me pour DaysOfWeek √† moins que vous ne rentriez vous-m√™me les donn√©es dans la bdd ou √† l'aide d'une fixture.
                        
        B - Cr√©er un event

                1. Avant de commencer, v√©rifiez que vous avez rempli correctement votre entit√© DaysOfWeek avec les 'name' des jours de la semaine et leur 'number'. 

                2. Si oui, dans Session.php v√©rifiez que la fonction $daysOfWeeks (attention au 's' √† la fin) est bien pr√©sente et persist√©e. 

                        /**
                        * @ORM\ManyToMany(targetEntity=DaysOfWeek::class, mappedBy="sessions", cascade={"persist, remove"})
                        */
                        private $daysOfWeeks;

                Par ailleurs, v√©rifiez aussi la pr√©sence des m√©thodes addDaysOfWeek() et getDaysOfWeeks(). 

                3. Dans SessionType.php ajoutez daysOfWeeks au builder. 
                        ‚ö† On ajoute bien le param√®tre daysOfWeeks (le 's' !!) qui relie Session √† DaysOfWeek et gr√¢ce auquel on va r√©cup√©rer les valeurs √† l'int√©rieur, sinon √ßa ne fonctionne pas.
                Le formulaire r√©cup√©rera les donn√©es d'une entit√© avec EntityType::class. Dans un array on pr√©cise les options possibles: la classe d'o√π l'on va prendre les donn√©es avec 'class', de quelle(s) colonne(s) les valeurs mises en avant sont tir√©es avec 'choice_label' et enfin le format de choix : 'multiple' et 'expanded' (boolean) pass√©s √† true permettent d'avoir plusieurs cases que l'on peut cocher. 

                        {
                        $builder
                                (...)
                                ->add('daysOfWeeks', EntityType::class, ['class' => DaysOfWeek::class, 'choice_label' => 'name', 'multiple' => true, 'expanded' => true])
                                ;
                        }
                Si tout se passe bien vous devriez pouvoir enregistrer une session en tant qu'event r√©current ou continu. Si vous remarquez un probl√®me d'enregistrement en base de donn√©es suivez l'instruction 4. sinon passez directement au point C sur l'affichage du calendrier.

                4. Dans SessionController.php, plus pr√©cisemment sur la route de cr√©ation d'une session il va falloir modifier la fonction new(). Si vous avez rencontr√© un probl√®me d'enregistrement en bdd, il se peu que votre relation ManyToMany n'ait pas √©t√© cr√©√©e dans le bon owner ce qui entraine un probl√®me pour persister les donn√©es en bdd. Il faut obliger Symfony a persister gr√¢ce √† une boucle. On it√®re sur chaque objet de la classe DaysOfWeek que l'on a cr√©√© pour les ajouter un √† un dans l'objet session en cours d'enregistrement. 
                        /**
                        * @Route("/session/new", name="session_new", methods={"GET","POST"})
                        */
                        public function new(Request $request): Response
                        {
                                (...)
                                if ($form->isSubmitted() && $form->isValid()) {
                                        foreach ($session->getDaysOfWeeks() as $dow) {
                                                $dow->addSession($session);
                                        }
                                        (...)
                                }
                        }
                Et l√†, √¥ miracle, un enregistrement!

        C - Affichage du calendrier 

                1. D√©terminez o√π vous souhaitez afficher votre calendrier. Le Dashboard c'est tr√®s bien pour ce CRM donc sus √† DashboardController.php!
                Dans la fonction index on v√©rifie l'injection du repository de Session et on se lance.
                Cr√©ez une variable qui va r√©cup√©rer toutes les sessions/events entr√©es en bdd avec un findAll().

                        $eventsSessions = $sessionRepository->findAll();

                Oui ce nom est pas g√©nial, trouvez mieux si vous osez.

                2. On va cr√©er un tableau pour chaque session. Ils seront reconnus par JS et affich√©s sur le calendrier ind√©pendamment les uns des autres. On instancie donc une variable avec un array vide avant de pouvoir le remplir. 

                        $rdvsSession = [];
                
                3. On va it√©rer sur chaque eventsSession pour pouvoir cr√©er un tableau de chaque. A l'int√©rieur d'une boucle foreach on va instancier un autre array vide cette fois ci pour les daysOfWeek. On r√©-it√®re (on refait une autre boucle quoi) sur daysOfWeek puisque c'est un tableau que l'on veut remplir. On va chercher les DaysOfWeeks de la session avec un getDaysOfWeeks() puis on fait un array_push(endroit_ou_je_stocke_mes_donnees, donnees_que_je_veux_stocker).
                        
                        foreach($eventsSessions as $eventSession){
                                $daysofWeeks = [];
                                foreach($eventSession->getDaysOfWeeks() as $d){
                                array_push($daysofWeeks, $d->getNumber().'');
                                }
                                (...)
                        }
                ‚ö† La concat√©nation est n√©cessaire avec les guillemets simples. On va chercher un 'number' qui correspond √† un integer en bdd, il n'a donc pas de guillemet. Le format du tableau daysOfWeek reconnu par fullCalendar n√©cessite cependant des guillements simples pour chaque nombre repr√©sentant un jour de la semaine.

                4. Maintenant que l'on a r√©cup√©rer les jours de la semaine de notre session on va pouvoir remplir notre tableau avec les valeurs associ√©es √† chaque propri√©t√© de Session. 

                        $rdvsSession[] = [
                                'id' => $eventSession->getId(),
                                'title' => $eventSession->getTitle(),
                                'start' => (!is_null($eventSession->getStart()))? $eventSession->getStart()->format('Y-m-d H:i:s') : null,
                                'end' => (!is_null($eventSession->getEnd()))? $eventSession->getEnd()->format('Y-m-d H:i:s') : null,
                                'description' => $eventSession->getDescription(),
                                'backgroundColor' => $eventSession->getBackgroundColor(),
                                'borderColor' => $eventSession->getBorderColor(),
                                'textColor' => $eventSession->getTextColor(),
                                'allDay' => $eventSession->getAllDay(),
                                'startTime' =>(!is_null($eventSession->getStartTime()))? $eventSession->getStartTime()->format('H:i:s') : null,
                                'endTime' => (!is_null($eventSession->getEndTime()))? $eventSession->getEndTime()->format(' H:i:s') : null,
                                'startRecur' => (!is_null($eventSession->getStartRecur()))? $eventSession->getStartRecur()->format('Y-m-d') : null,
                                'endRecur' => (!is_null($eventSession->getEndRecur()))? $eventSession->getEndRecur()->format('Y-m-d') : null,
                                'daysOfWeek' => $daysofWeeks,
                                'groupId' => $eventSession->getGroupId(),
                        ];
                Il faut √©tablir un format pour les datetime, les date et les time afin qu'ils s'affichent et soient reconnus correctement par JS.

                5. Maintenant que l'on a notre session/event, il faut l'afficher dans le JS. Mais pour cela il va falloir la traduire dans le format json. On cr√©e donc une variable qui va contenir nos informations transform√©es par la fonction json_encode().

                        $dataSession = json_encode($rdvsSession);
                
                Ensuite on envoie les donn√©es dans la vue pour qu'elles y soient affich√©es. 

                        return $this->render('dashboard/index.html.twig', ['dataSession' => $dataSession, 'eventsSessions' => $eventsSessions] );

                6. 




